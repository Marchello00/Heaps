#include <ctime>
#include <random>
#include <functional>
#include <Array.h>
#include <Heap.h>
#include <BinomialHeap.h>
#include <FibHeap.h>

void printRes(const std::string &s, int n, double t) {
    std::cout << s << " time with n = " << n << " queries is " << t << " seconds\n";
}

void fillCmd(int mod, Array<int> &cmd) {
    for (auto &c : cmd) {
        c = rand() % mod;
    }
}

template<typename T>
void print(const std::string &head, int n, std::function<double(PriorityQueue<T> *)> func, bool withHeap = true) {
    std::cout << head << ":\n\n\n";
    if (withHeap) {
        auto h = new Heap<int>;
        auto t1 = func(h);
        delete(h);
        printRes("Heap", n, t1);
    }
    auto *bh = new BinomialHeap<T>;
    auto t2 = func(bh);
    delete(bh);
    printRes("BinpmialHeap", n, t2);
    auto *fh = new FibHeap<T>;
    auto t3 = func(fh);
    delete(fh);
    printRes("FibHeap", n, t3);
    std::cout << "\n-----------------------------------------\n\n";
}

TEST(SpeedTest, InsertErase) {
    int seed = 100500;
    srand(seed);
    int n = (int) 1e6;
    Array<int> cmd(n);
    fillCmd(3, cmd);
    auto proc = [&](PriorityQueue<int> *heap) {
        int seed2 = seed * 104;
        srand(seed2);
        auto tm = clock();
        Array<PriorityQueue<int>::Pointer> ptrs;
        for (auto c : cmd) {
            switch (c) {
                case 0: {
                    heap->insert(rand());
                    break;
                }
                case 1: {
                    try {
                        heap->extractMin();
                    } catch (...) { }
                    break;
                }
                case 2: {
                    try {
                        heap->getMin();
                    } catch (...) { }
                    break;
                }
                default:break;
            }
        }
        return double(clock() - tm) / CLOCKS_PER_SEC;
    };
    print<int>("Insert and erase time test", n, proc);
}

TEST(SpeedTest, InsertChange) {
    int seed = 100500;
    srand(seed);
    int n = (int) 1e6;
    Array<int> cmd(n);
    for (int i = 0; i < n; ++i) {
        cmd[i] = rand() % 2;
    }
    auto proc = [&](PriorityQueue<int> *heap) {
        int seed2 = seed * 104;
        srand(seed2);
        auto tm = clock();
        Array<PriorityQueue<int>::Pointer> ptrs;
        for (auto c : cmd) {
            switch (c) {
                case 0: {
                    ptrs.push(heap->insert(rand()));
                    break;
                }
                case 1: {
                    if (ptrs.empty()) continue;
                    *ptrs[rand() % ptrs.size()] = rand();
                    break;
                }
                default:break;
            }
        }
        return double(clock() - tm) / CLOCKS_PER_SEC;
    };
    print<int>("Insert ans change time test", n, proc);
}

TEST(SpeedTest, Insert) {
    int seed = 100500;
    srand(seed);
    int n = (int) 1e6;
    auto proc = [&](PriorityQueue<int> *heap) {
        int seed2 = seed * 104;
        srand(seed2);
        auto tm = clock();
        for (int i = 0 ; i < n; ++i) {
            heap->insert(rand());
        }
        return double(clock() - tm) / CLOCKS_PER_SEC;
    };
    print<int>("Insert time test", n, proc);
}

TEST(SpeedTest, InsertAndMerge) {
    int seed = 100500;
    srand(seed);
    int n = (int) 1e6;
    auto proc = [&](PriorityQueue<int> *heap) {
        int seed2 = seed * 104;
        srand(seed2);
        bool isBH = dynamic_cast<BinomialHeap<int> *>(heap);
        PriorityQueue<int> *heap2 = nullptr;
        if (isBH) {
            heap2 = new BinomialHeap<int>;
        } else {
            heap2 = new FibHeap<int>;
        }
        auto tm = clock();
        for (int i = 0; i < n; ++i) {
            heap->insert(rand());
            heap2->insert(rand());
        }
        if (isBH) {
            dynamic_cast<BinomialHeap<int> *>(heap)->merge(*dynamic_cast<BinomialHeap<int> *>(heap2));
        } else {
            dynamic_cast<FibHeap<int> *>(heap)->merge(*dynamic_cast<FibHeap<int> *>(heap2));
        }
        delete heap2;
        return double(clock() - tm) / CLOCKS_PER_SEC;
    };
    print<int>("Insert and merge test", n, proc, false);
}

TEST(SpeedTest, InsertChangeErase) {
    int seed = 100500;
    srand(seed);
    int n = (int) 1e6;
    auto proc = [&](PriorityQueue<int> *heap) {
        auto tm = clock();
    };
}